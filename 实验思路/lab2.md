# Lab2

首先该算法核心成员是领导者，跟随者以及候选者三种身份，日志条目仅从领导者流向其他服务器。Raft 使用随机定时器来选举领导者。这仅需在任何共识算法中已
必需的心跳机制上添加少量机制，同时简单且快速地解决冲突。还有一个很关键的概念，复制状态机：复制状态机被用于解决分布式系统中的多种容错问题。例如，
许多依赖单一集群领导者的大型系统，通常使用一个独立的复制状态机来管理领导者选举，并存储必须在领导者崩溃后仍然可用的配置信息。
复制状态机通常通过一个复制日志来实现。每个服务器都存储一个包含一系列命令的日志，其状态机会按顺序执行这些命令。
每份日志都包含相同的命令且顺序一致，因此每台状态机会处理相同的命令序列。由于状态机是确定性的，它们会计算出相同的状态和相同的输出序列。
保持复制日志的一致性是共识算法的工作。服务器上的共识模块接收来自客户端的命令，并将其添加到日志中。它通过与其他服务器上的共识模块通信，
确保每份日志最终都包含相同的请求并以相同的顺序排列，即使某些服务器发生故障也是如此。当命令被正确复制后，
每台服务器的状态机会按日志顺序处理这些命令，并将输出返回给客户端。最终，这些服务器对外表现为一个高度可靠的单一状态机。
Raft 是一种用于管理复制日志的算法，Raft 通过首先选举出一个领导者来实现共识，然后赋予领导者完全的责任来管理复制日志。领导者负责从客户端接收日志条目，
将它们复制到其他服务器，并告知这些服务器何时可以将日志条目安全地应用到它们的状态机中。leader和follower之间通信主要有两个方法一个是AppendEntries另一个是RequestVote,
AppendEntries有两个作用一个是同步日志另一个是发送心跳，发送心跳的时候，其中要同步的日志条目就为空,会先判断当前的任期是不是大于或等于接收者的任期，
如果小于那么接收者会返回false,。而不为心跳是就传递要先判断是否合规，然后append日志.并向 Leader 发送 AppendEntriesReply 消息。Leader 通过 AppendEntries 消息定期发送心跳信号，确保 Follower 知道当前 Leader，并防止 Follower 触发选举。
当有新的日志条目产生时，Leader 会将其复制到 Follower。 Leader 等待大多数 Follower 的确认后，将日志条目标记为已提交（通过更新 commitIndex）。
Follower 接收到更新的 commitIndex 后，将日志条目应用到状态机，保持状态一致性。

## Part A


踩坑 :
1.当选举人的任期必须要大于被选举的任期，不能等于，等于会造成 双leader情况
2.当两个都是候选者，低任期应该为高任期投票,也就是候选者也要投票

实现 Raft 的领导者选举和心跳功能（AppendEntries RPC 不携带日志条目）。2A 部分的目标是确保系统能够选出一个领导者，
在没有故障的情况下领导者能够持续担任其角色，并且当旧的领导者失效或通信丢失时，新领导者能够接任       


理清代码逻辑：首先就是在创建好一个节点后，该节点的状态应该为候选者，然后选举间隔，如果在选举间隔时间超时前收到领导者心跳那么就变为跟随着，如果超时没收到，
那么发起选举，这时候又有多种情况，如果得到半数的选票，那么成为领导者，并立刻发送心跳给跟随者，收到心跳的跟随者应该也重置选举间隔和心跳检测
(要不要重置选举定时器)。如果没有收到半数的选票，并且收到比自己节点大的任期应该更新自己的任期为更大任期，并转为跟随者（这里可能错误了）。
应该是在心跳超时的时候从跟随者转变为候选者。


## PartB

